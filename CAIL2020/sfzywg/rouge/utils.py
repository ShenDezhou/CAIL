import yaml
import codecs
import os
import time
import sys
from data.script.PythonROUGE import PythonROUGE
from data.script.SARI import SARIsent

class AttrDict(dict):

    def __init__(self, *args, **kwargs):
        super(AttrDict, self).__init__(*args, **kwargs)
        self.__dict__ = self



def read_config(path):
    return AttrDict(yaml.load(open(path, 'r')))

def read_datas(filename, trans_to_num=False):
    lines = open(filename, 'r').readlines()
    lines = list(map(lambda x: x.split(), lines))
    if trans_to_num:
        lines = [list(map(int, line)) for line in lines]
    return lines

def save_datas(data, filename, trans_to_str=False):
    if trans_to_str:
        data = [list(map(str, line)) for line in data]
    lines = list(map(lambda x: " ".join(x), data))
    with open(filename, 'w') as f:
        f.write("\n".join(lines))



def eval_bleu(reference, candidate, log_path, config):
    ref_file = log_path+'reference.txt'
    cand_file = log_path+'candidate.txt'
    with codecs.open(ref_file, 'w', 'utf-8') as f:
        for s in reference:
            f.write("".join(s)+'\n')
    with codecs.open(cand_file, 'w', 'utf-8') as f:
        for s in candidate:
            f.write("".join(s).strip()+'\n')

    temp = log_path + "result.txt"
    if hasattr(config, 'ref_file'):
        ref_file = config.ref_file
    command = "perl data/script/multi-bleu.perl " + ref_file + "<" + cand_file + "> " + temp
    os.system(command)
    with open(temp) as ft:
        result = ft.read()
    os.remove(temp)

    return result

def eval_rouge(reference, candidate, log_path):
    assert len(reference) == len(candidate)

    ref_dir = log_path + 'reference/'
    cand_dir = log_path + 'candidate/'
    if not os.path.exists(ref_dir):
        os.mkdir(ref_dir)
    if not os.path.exists(cand_dir):
        os.mkdir(cand_dir)
    ref_file = ref_dir+'reference'
    cand_file = cand_dir+'candidate'

    for i in range(len(reference)):
        with codecs.open(ref_file+str(i), 'w', 'utf-8') as f:
            f.write("".join(reference[i]).replace(" <\s> ", "\n")+'\n')
        with codecs.open(cand_file+str(i), 'w', 'utf-8') as f:
            f.write("".join(candidate[i]).replace(" <\s> ", "\n")+'\n')

    reference_set = [[ref_file+str(i)] for i in range(len(reference))]
    candidate_set = [cand_file+str(i) for i in range(len(candidate))]
    recall, precision, F_measure = PythonROUGE(candidate_set, reference_set, ngram_order=2)

    recall = [round(score * 100, 2) for score in recall]
    precision = [round(score * 100, 2) for score in precision]
    F_measure = [round(score * 100, 2) for score in F_measure]

    return {'recall': recall, 'precision': precision, 'F_measure': F_measure}



def eval_multi_rouge(reference, candidate, log_path):

    ref_dir = log_path + 'reference/'
    cand_dir = log_path + 'candidate/'
    if not os.path.exists(ref_dir):
        os.mkdir(ref_dir)
    if not os.path.exists(cand_dir):
        os.mkdir(cand_dir)
    ref_file = ref_dir + 'reference'
    cand_file = cand_dir+'candidate'

    for i in range(len(candidate)):
        with codecs.open(cand_file+str(i), 'w', 'utf-8') as f:
            f.write("".join(candidate[i]).replace(" <\s> ", "\n")+'\n')

    reference_set = [[] for i in range(len(candidate))]
    for i in range(4):
        lines = codecs.open('/home/mashuming/data/summarization/giga/DUC2004/task1_ref'+str(i)+'.txt','r','utf8').read().strip().split('\n')
        for j, line in enumerate(lines):
            with codecs.open(ref_file+'_'+str(i)+'_'+str(j),'w','utf8') as f:
                f.write(line+'\n')
            reference_set[j].append(ref_file+'_'+str(i)+'_'+str(j))

    candidate_set = [cand_file+str(i) for i in range(len(candidate))]
    recall, precision, F_measure = PythonROUGE(candidate_set, reference_set, ngram_order=2, byte=75)

    recall = [round(score * 100, 2) for score in recall]
    precision = [round(score * 100, 2) for score in precision]
    F_measure = [round(score * 100, 2) for score in F_measure]

    return {'recall': recall, 'precision': precision, 'F_measure': F_measure}



def eval_SARI(source, reference, candidate, log_file, config):
    assert len(reference) == len(candidate)
    assert len(source) == len(reference)

    scores = []
    if hasattr(config, 'ref_file'):
        refs = [[] for _ in range(len(candidate))]
        for i in range(9):
            file_name = config.ref_file+str(i)
            lines = codecs.open(file_name, 'r', 'utf-8').read().strip().split('\n')
            assert len(lines) == len(candidate)
            for j, line in enumerate(lines):
                refs[j].append(line)
    else:
        refs = [[" ".join(r)] for r in reference]

    for s, c, r in zip(source, candidate, refs):
        scores.append(SARIsent(" ".join(s), " ".join(c), r))

    return float(sum(scores)) * 100.0 / max(len(scores), 1)


def logging(file):
    def write_log(s):
        print(s, end='')
        with open(file, 'a') as f:
            f.write(s)
    return write_log



_, term_width = os.popen('stty size', 'r').read().split()
term_width = int(term_width)

TOTAL_BAR_LENGTH = 86.
last_time = time.time()
begin_time = last_time
def progress_bar(current, total, msg=None):
    global last_time, begin_time
    current = current % total
    if current == 0:
        begin_time = time.time()  # Reset for new bar.

    cur_len = int(TOTAL_BAR_LENGTH*current/total)
    rest_len = int(TOTAL_BAR_LENGTH - cur_len) - 1

    sys.stdout.write(' [')
    for i in range(cur_len):
        sys.stdout.write('=')
    sys.stdout.write('>')
    for i in range(rest_len):
        sys.stdout.write('.')
    sys.stdout.write(']')

    cur_time = time.time()
    step_time = cur_time - last_time
    last_time = cur_time
    tot_time = cur_time - begin_time

    L = []
    L.append('  Step: %s' % format_time(step_time))
    L.append(' | Tot: %s' % format_time(tot_time))
    if msg:
        L.append(' | ' + msg)

    msg = ''.join(L)
    sys.stdout.write(msg)
    for i in range(term_width-int(TOTAL_BAR_LENGTH)-len(msg)-3):
        sys.stdout.write(' ')

    # Go back to the center of the bar.
    for i in range(term_width-int(TOTAL_BAR_LENGTH/2)):
        sys.stdout.write('\b')
    sys.stdout.write(' %d/%d ' % (current+1, total))

    if current < total-1:
        sys.stdout.write('\r')
    else:
        sys.stdout.write('\n')
    sys.stdout.flush()

def format_time(seconds):
    days = int(seconds / 3600/24)
    seconds = seconds - days*3600*24
    hours = int(seconds / 3600)
    seconds = seconds - hours*3600
    minutes = int(seconds / 60)
    seconds = seconds - minutes*60
    secondsf = int(seconds)
    seconds = seconds - secondsf
    millis = int(seconds*1000)

    f = ''
    i = 1
    if days > 0:
        f += str(days) + 'D'
        i += 1
    if hours > 0 and i <= 2:
        f += str(hours) + 'h'
        i += 1
    if minutes > 0 and i <= 2:
        f += str(minutes) + 'm'
        i += 1
    if secondsf > 0 and i <= 2:
        f += str(secondsf) + 's'
        i += 1
    if millis > 0 and i <= 2:
        f += str(millis) + 'ms'
        i += 1
    if f == '':
        f = '0ms'
    return f